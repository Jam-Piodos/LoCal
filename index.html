<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="initial-scale=1.0">
  <title>Project Kalasan - Lot Plotter</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.3.1/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.3.1/dist/leaflet.js"></script>

  <style>
    #map { height: 100vh; width: 100%; }
  </style>
</head>
<body>
  <div id="map"></div>

  <script>
    // === Local survey coordinates (exclude tie line) ===
    const localCoords = [
      { id: 1, northing: 23425.240, easting: 23198.620 },
      { id: 2, northing: 23111.940, easting: 23519.570 },
      { id: 3, northing: 23064.430, easting: 23301.590 },
      { id: 4, northing: 23203.940, easting: 23018.230 }
    ];

    // === Known GPS control points (matching the survey points) ===
    const gpsCoords = [
      { id: 1, lat: 8.398673, lng: 124.894305 },
      { id: 2, lat: 8.398230, lng: 124.895121 },
      { id: 3, lat: 8.397676, lng: 124.894605 },
      { id: 4, lat: 8.398102, lng: 124.893790 }
    ];

    // --- Helper: compute similarity transform (Helmert) ---
    function computeSimilarity(local, gps) {
      const n = local.length;
      let sumX = 0, sumY = 0, sumU = 0, sumV = 0;
      for (let i = 0; i < n; i++) {
        sumX += local[i].easting;
        sumY += local[i].northing;
        sumU += gps[i].lng;
        sumV += gps[i].lat;
      }

      const meanX = sumX / n, meanY = sumY / n;
      const meanU = sumU / n, meanV = sumV / n;

      let Suv = 0, Suw = 0, Svw = 0, Svv = 0;
      for (let i = 0; i < n; i++) {
        const x = local[i].easting - meanX;
        const y = local[i].northing - meanY;
        const u = gps[i].lng - meanU;
        const v = gps[i].lat - meanV;
        Suv += u*x + v*y;
        Suw += u*y - v*x;
        Svv += u*u + v*v;
      }

      const s = Math.sqrt((Suv*Suv + Suw*Suw) / ( (local.reduce((a,c)=>a+(c.easting-meanX)**2+(c.northing-meanY)**2,0)) ));
      const cosTheta = Suv / (s * (local.reduce((a,c)=>a+(c.easting-meanX)**2+(c.northing-meanY)**2,0)));
      const sinTheta = Suw / (s * (local.reduce((a,c)=>a+(c.easting-meanX)**2+(c.northing-meanY)**2,0)));

      return { meanX, meanY, meanU, meanV, s, cosTheta, sinTheta };
    }

    // --- Transform function ---
    function applySimilarity(pt, params) {
      const dx = pt.easting - params.meanX;
      const dy = pt.northing - params.meanY;
      const lng = params.meanU + params.s * (params.cosTheta*dx - params.sinTheta*dy);
      const lat = params.meanV + params.s * (params.sinTheta*dx + params.cosTheta*dy);
      return [lat, lng];
    }

    // Compute similarity params
    const params = computeSimilarity(localCoords, gpsCoords);

    // Transform all survey points
    const lotPoints = localCoords.map(pt => applySimilarity(pt, params));

    // === Initialize Map ===
    const map = L.map('map').setView([gpsCoords[0].lat, gpsCoords[0].lng], 18);

    // Satellite basemap
    L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
      attribution: 'Tiles Â© Esri'
    }).addTo(map);

    // Draw polygon
    L.polygon(lotPoints, { color: 'orange' }).addTo(map).bindPopup("Lot Boundary");

    // Add transformed points (blue)
    lotPoints.forEach((pt, i) => {
      L.circleMarker(pt, { radius: 6, color: 'blue', fillColor: 'cyan', fillOpacity: 0.8 })
        .addTo(map)
        .bindPopup("Transformed Point " + (i+1));
    });

    // Add control GPS points (green)
    gpsCoords.forEach((pt, i) => {
      L.circleMarker([pt.lat, pt.lng], { radius: 6, color: 'green', fillColor: 'lime', fillOpacity: 0.8 })
        .addTo(map)
        .bindPopup("Control Point " + (i+1));
    });

    // Fit map to polygon
    map.fitBounds(lotPoints);
  </script>
</body>
</html>

